# rust-auth-service: A High-Performance Rust Authentication API

A minimal, production-ready RESTful API for user authentication built entirely in Rust. This service provides a secure, modern, and high-performance backend solution for handling user registration, login, and session management using stateless JSON Web Tokens (JWT).

This project was developed as a technical evaluation, demonstrating a deep understanding of Rust's async ecosystem, modern web frameworks, and secure API design principles. The focus is on creating a service that is type-safe, memory-safe, and highly concurrent by leveraging non-blocking I/O.

## Core Features

- **Secure Registration**: `POST /register` endpoint accepts user credentials, securely hashes the password using bcrypt, and persists the new user to the database.
- **Stateless Authentication**: `POST /login` endpoint validates credentials and, upon success, generates and returns a stateless JWT signed with a server-side secret.
- **Protected Routes**: `GET /me` endpoint demonstrates a protected route. It requires a valid `Authorization: Bearer <token>` header, which is validated using a custom Axum extractor.
- **Modular Architecture**: The codebase is organized into distinct modules (routes, handlers, services, models) to promote separation of concerns and maintainability.

## Tech Stack & Architectural Decisions

This service is built with a curated stack of modern, high-performance libraries, chosen to maximize safety, speed, and developer ergonomics.

| Component | Technology | Rationale |
|-----------|-----------|-----------|
| Language | Rust | Provides compile-time guarantees for memory and thread safety, delivering C-like performance without the associated risks. |
| Web Framework | Axum (0.7) | A modern, ergonomic web framework built by the Tokio team. It uses a "macro-free" API and a modular Router system that integrates seamlessly with the tower ecosystem. |
| Async Runtime | Tokio | The industry-standard async runtime for Rust, enabling massive concurrency with a non-blocking, event-driven architecture. |
| ORM & Database | Diesel (Async) & PostgreSQL | Diesel is a type-safe ORM that catches SQL errors at compile time. The diesel-async crate provides true asynchronous database communication, preventing I/O from blocking server threads. |
| Containerization | Docker Compose | The PostgreSQL database is fully containerized with Docker, ensuring a clean, reproducible, and isolated environment for development and testing. |
| Authentication | bcrypt & jsonwebtoken | Implements industry-best-practices: bcrypt for one-way password hashing (computationally "slow" by design) and jsonwebtoken (JWT) for stateless, verifiable authentication tokens. |
| Logging | tracing | A powerful framework for structured, context-aware logging. All server events, requests, and errors are logged to the console for observability. |
| Serialization | serde | The standard for high-performance JSON (de)serialization, used to parse request payloads and serialize responses. |

## Project Structure

The project follows a clean, modular design to separate concerns:

```
.
├── src/
│   ├── auth.rs        # JWT validation logic & Axum extractor (`AuthUser`)
│   ├── handlers.rs    # API request/response logic (controllers)
│   ├── main.rs        # Application entrypoint (server setup, tracing, .env)
│   ├── models.rs      # Diesel data models (`User`, `NewUser`)
│   ├── routes.rs      # Axum router configuration (`create_router`)
│   ├── schema.rs      # (Auto-generated by Diesel)
│   └── services.rs    # Business logic (e.g., `user_service::create_user`)
├── migrations/
│   └── ..._create_users # Diesel migration files for the `users` table
├── .env.example       # Example environment file
├── Cargo.toml         # Rust dependencies
└── docker-compose.yml # Docker service definition for PostgreSQL
```

## Prerequisites

- **Rust & Cargo**: Install from [rustup.rs](https://rustup.rs/)
- **Docker Desktop**: Required to run the PostgreSQL database
- **PostgreSQL Client Libraries (libpq)**: Required for the diesel crate to compile on your host machine
  - **On Windows**: The easiest way is to [install PostgreSQL](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads) on your Windows machine. This provides the libpq.lib file. You must also add the lib folder (e.g., `C:\Program Files\PostgreSQL\16\lib`) to your `LIB` environment variable.
- **diesel_cli**: The command-line tool for managing migrations
  ```bash
  cargo install diesel_cli --no-default-features --features postgres
  ```

## Installation & Running

### Clone the Repository

```bash
git clone https://github.com/your-username/rust-auth-service.git
cd rust-auth-service
```

### Set Up Environment

Create a `.env` file from the example. This file stores your secrets.

```bash
# On Windows
copy .env.example .env

# On macOS/Linux
cp .env.example .env
```

Now, open `.env` and fill in the fields. The defaults should work fine:

```env
DATABASE_URL=postgres://postgres:yourpassword@localhost:5432/postgres
RUST_LOG=info
JWT_SECRET=a-very-secure-secret-key
```

### Start the Database

This command starts the PostgreSQL database in a Docker container:

```bash
docker-compose up -d
```

### Run Database Migrations

This command connects to the Docker database and creates the users table:

```bash
diesel migration run
```

### Run the Application

You're ready to go!

```bash
cargo run
```

The server will start on `http://127.0.0.1:3000`. You will see logs in your console thanks to tracing.

## API Endpoints

You can test these endpoints using a tool like Insomnia or Postman.

| Method | Endpoint | Description | Auth Required | Body |
|--------|----------|-------------|----------------|------|
| POST | `/register` | Creates a new user account. | No | `{ "email": "...", "password": "..." }` |
| POST | `/login` | Logs in a user. | No | `{ "email": "...", "password": "..." }` |
| GET | `/me` | Retrieves the authenticated user's details. | Yes (Bearer Token) | (None) |

## Testing the API

### Register a New User

```bash
curl -X POST http://127.0.0.1:3000/register \
  -H "Content-Type: application/json" \
  -d '{"email": "user@example.com", "password": "securepassword"}'
```

### Login

```bash
curl -X POST http://127.0.0.1:3000/login \
  -H "Content-Type: application/json" \
  -d '{"email": "user@example.com", "password": "securepassword"}'
```

This will return a JWT token in the response.

### Access Protected Route

```bash
curl -X GET http://127.0.0.1:3000/me \
  -H "Authorization: Bearer <your_jwt_token>"
```

## Security Considerations

- Passwords are hashed using bcrypt with a cost factor of 12, making brute-force attacks computationally expensive.
- JWTs are signed with a secret key and validated on every protected request.
- All environment variables (database credentials, JWT secret) should be stored securely and never committed to version control.
- The `.env` file is excluded from Git (via `.gitignore`) to prevent accidental exposure of secrets.

## Performance & Scalability

This service is designed to handle high concurrency:

- **Async/Await**: All I/O operations are non-blocking, allowing the server to handle thousands of concurrent connections efficiently.
- **Connection Pooling**: Database connections are pooled to minimize overhead from connection initialization.
- **Type Safety**: Rust's type system catches many potential bugs at compile time, reducing runtime errors and improving reliability.
- **Zero-Copy Deserialization**: Serde's efficiency in JSON parsing ensures minimal CPU overhead.

## License

This project is open source and available under the MIT License.

## Contributing

Contributions are welcome! Please feel free to open issues or submit pull requests to improve this project.

## Acknowledgments

This project demonstrates a robust, modern, and scalable approach to backend development using Rust's powerful async ecosystem and industry-best-practices for API security.
